"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const util_1 = require("util");
const testingbot_tunnel_launcher_1 = __importDefault(require("testingbot-tunnel-launcher"));
const logger_1 = __importDefault(require("@wdio/logger"));
const log = logger_1.default('@wdio/testingbot-service');
class TestingBotLauncher {
    constructor(options) {
        this.options = options;
    }
    async onPrepare(config, capabilities) {
        var _a;
        if (!this.options.tbTunnel || !config.user || !config.key) {
            return;
        }
        const tbTunnelIdentifier = ((_a = this.options.tbTunnelOpts) === null || _a === void 0 ? void 0 : _a.tunnelIdentifier) || `TB-tunnel-${Math.random().toString().slice(2)}`;
        this.tbTunnelOpts = Object.assign({
            apiKey: config.user,
            apiSecret: config.key,
            'tunnel-identifier': tbTunnelIdentifier,
        }, this.options.tbTunnelOpts);
        if (Array.isArray(capabilities)) {
            for (const capability of capabilities) {
                if (!capability['tb:options']) {
                    capability['tb:options'] = {};
                }
                capability['tb:options']['tunnel-identifier'] = tbTunnelIdentifier;
            }
        }
        else {
            for (const browserName of Object.keys(capabilities)) {
                const capability = capabilities[browserName].capabilities;
                if (!capability['tb:options']) {
                    capability['tb:options'] = {};
                }
                capability['tb:options']['tunnel-identifier'] = tbTunnelIdentifier;
            }
        }
        const obs = new perf_hooks_1.PerformanceObserver((list) => {
            const entry = list.getEntries()[0];
            log.info(`TestingBot tunnel successfully started after ${entry.duration}ms`);
        });
        obs.observe({ entryTypes: ['measure'], buffered: false });
        perf_hooks_1.performance.mark('tbTunnelStart');
        this.tunnel = await util_1.promisify(testingbot_tunnel_launcher_1.default)(this.tbTunnelOpts);
        perf_hooks_1.performance.mark('tbTunnelEnd');
        perf_hooks_1.performance.measure('bootTime', 'tbTunnelStart', 'tbTunnelEnd');
    }
    onComplete() {
        if (!this.tunnel) {
            return;
        }
        return new Promise(resolve => this.tunnel.close(resolve));
    }
}
exports.default = TestingBotLauncher;
